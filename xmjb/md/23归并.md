# 小马加编信息学教案(二十三)
#  归并排序


<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [一. 课程内容](#一-课程内容)
* [二. 知识讲解](#二-知识讲解)
	* [1. 归并排序](#1-归并排序)
* [三. 经典例题](#三-经典例题)
* [四. 提高巩固](#四-提高巩固)

<!-- /code_chunk_output -->
## 一. 课程内容
1. 归并排序学习
---

## 二. 知识讲解

### 1. 归并排序

>归并排序是一种效率较优的排序算法。归并排序需要用到分治的思想。

>先考虑一个子问题：
数组a[1..n]与b[1..m]都已经从小到大排序。该如何将它们合并为一个数组c[1..n+m]，c中元素也从小到大排列？

>先考虑c[1]，c[1]必然是a[1]和b[1]中较小的一个。如果a[1]<b[1]，那么c[1]=a[1]，且c[2]必然是a[2]和b[1]中较小的一个......如此类推，就可以得到从小到大排序的数组c了。下面是核心代码。
```c++
void solve()
{
	i=j=1;
	len=0;
	while(i<=n || j<=m)
	{
		if(i>n) c[++len]=b[j++];
		else if(j>m) c[++len]=a[i++];
		else
		{
			if(a[i]<b[j]) c[++len]=a[i++];
			else c[++len]=b[j++];
		}
	}
}
```

>其中i，j分别表示a，b中当前用于比较的位置。

>解决了子问题，再回到归并排序。以下是核心代码。

```c++
void c_sort(int l,int r)
{
	if(l==r) return;
	int mid=(l+r)/2;
	c_sort(l,mid);
	c_sort(mid+1,r);

	solve(l,mid,mid+1,r);
}
```
>其中c_sort(l,r)表示要将a[ l .. r]排序，调用c_sor(1,n)就可以将数组a排序。
solve(l,mid,mid+1,r)作用是将a[ l .. mid ]，a[ mid+1 .. r]作为两个已经有序的数组，合并排序后变成有序的a[ l ..r ]。其实现方法在上文已经提到。

>执行完c_sort(l,mid)、c_sort(mid+1,r)后，a[ l .. mid ]、a[ mid+1 .. r ]这两部分都有序，所以执行solve(l,mid,mid+1,r)后a[ l .. r ]也有序。由分治的思想可知，执行完c_sort(1,n)后，a[ 1 .. n ]会从小到大排序。

## 三. 经典例题

1. 给出数组a，在纸上画出归并排序每次调用完c_sort后的数组a。
>a：1 2 1 3 4 2 3 5

>a：2 3 4 2 1 4 6

>a：7 8 3 2 1 4 2 2 3

2. 编程实现归并排序
>给出数组a，从小到大排序后输出

>输入格式：
第一行一个数字n，表示数组有n个元素。
第二行n个正整数，表示数组a。

>输出格式：
一行n个整数，表示从小到大排序后的数组a。

样例输入 | 样例输出
------------ | ------------
5  </br> 1 3 2 5 4 | 1 2 3 4 5


## 四. 提高巩固

1. 生日
>cjf君想调查学校OI组每个同学的生日，并按照从大到小的顺序排序。但cjf君最近作业很多，没有时间，所以请你帮她排序。

>输入格式：
有2行，第1行为OI组总人数n；
第2行至第n+1行分别是每人的姓名s、出生年y、月m、日d。

>输出格式：
有n行，即n个生日从大到小同学的姓名。(如果有两个同学生日相同,输入靠后的同学先输出)



样例输入 | 样例输出
------------ | ------------
3</br>Yangchu 1992 4 23</br>Qiujingya 1993 10 13</br>Luowen 1991 8 1 | Luowen</br>Yangchu</br>Qiujingya

2. 瑞士轮（noip2011普及组）
>2×N 名编号为 1∼2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。
>
>每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第2K - 1名和第2K名、…… 、第2N − 1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。
>
>现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。

>输入格式：
第一行是三个正整数N,R,Q,每两个数之间用一个空格隔开，表示有 2×N名选手、R 轮比赛，以及我们关心的名次 Q。
>
>第二行是2×N 个非负整数$s_1, s_2, …, s_{2N}$，每两个数之间用一个空格隔开，其中$s_i$表示编号为i 的选手的初始分数。 
第三行是2×N 个正整数$w_1 , w_2 , …, w_{2N}$ ，每两个数之间用一个空格隔开，其中 $w_i$表示编号为i的选手的实力值。
$N \le 100000$
$R\le50$
$s_i,w_i\le10^8$

>输出格式：
一个整数，即R 轮比赛结束后，排名第Q 的选手的编号。

样例输入 | 样例输出
------------ | ------------
2 4 2 </br>7 6 6 7 </br>10 5 20 15  | 1