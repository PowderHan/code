
# 小马加编信息学教案(三十六) 
# STL（vector，stack，queue， priority_queue）

---

<!-- code_chunk_output -->

* [一. 课程内容](#一-课程内容)
* [二. 知识讲解](#二-知识讲解)
	* [1. 什么是STL？](#1-什么是stl)
	* [2. $vector$](#2-vector)
		* [2. 1 $vector$的介绍](#2-1-vector的介绍)
		* [2. 2 $vector$的定义](#2-2-vector的定义)
		* [2. 3 $vector$的访问](#2-3-vector的访问)
		* [2. 4 $vector$的常用函数](#2-4-vector的常用函数)
		* [2. 5 $vector$的应用](#2-5-vector的应用)
    * [3. $stack$](#3-stack)
		* [3. 1 $stack$的介绍](#3-1-stack的介绍)
		* [3. 2 $stack$的定义](#3-2-stack的定义)
		* [3. 3 $stack$的常用函数](#3-3-stack的常用函数)
    * [4. $queue$](#4-queue)
		* [4. 1 $queue$的介绍](#4-1-queue的介绍)
		* [4. 2 $queue$的定义](#4-2-queue的定义)
		* [4. 3 $queue$的常用函数](#4-3-queue的常用函数)
    * [5. $priority$_$queue$](#5-priority_queue)
		* [5. 1 $priority$_$queue$的介绍](#5-1-priority_queue的介绍)
		* [5. 2 $priority$_$queue$的定义](#5-2-priority_queue的定义)
		* [5. 3 $priority$_$queue$的常用函数](#5-3-priority_queue的常用函数)

<!-- /code_chunk_output -->

---

## 一. 课程内容
1. 什么是STL？
2. $vector$
3. $stack$
4. $queue$
5. $priority$_$queue$
---

## 二. 知识讲解

### 1. 什么是STL？

> 编写程序不只可以用C++一种语言，那我们为什么要使用C++呢？

> 一个原因是它效率高且容易编写.
> 另一个原因是它自带了标准模板库（Standard Template Library），也就是我们所说的STL，其中封装了很多实用的容器，也可以理解成能够实现很多功能的系统函数，或者说用来存放数据的对象，开发者可以根据接口规范（调用格式）直接调用，而不用关心其内部实现的原理和具体代码，十分方便快捷。

> 我们常用的容器有```vector、stack、queue、map、set```等。使用STL中的函数，一般都要在头文件后加上```using namespace std```。

### 2. $vector$

##### 2. 1 $vector$的介绍

> $vector$直接翻译为**向量**，一般说成**变长数组**，即**长度根据需要而自动改变的数组**。

> 在信息学竞赛中，有些题目需要定义很大的数组，这样会出现**超出内存限制**的错误。比如，有$n$个容器，$m$个球，告诉你每个球是在哪个容器，问每个容器里面有哪些球，且$n,m$都等于$100000$。

> 第一种方法：对每个容器，遍历完所有的球，看一些有哪些球是属于这个容器，那么需要$O(nm)$的时间复杂度。

> 第二种方法：对每个容器，开一个长度为$m$的数组，记录里面有哪些球，虽然只用对所有球遍历一次，但是需要$O(nm)$的空间复杂度。

> 在第二种方法的存储中使用$vector$就很适合，由于每个数组可以任意改变长度，我总共只需要开$O(m)$的数组存放每个桶里有哪些球。


##### 2. 2 $vector$的定义

> 使用$vector$，首先需要添加$vector$头文件，即```#include <vector>```，同时，必须要有```using namespace std```（下面所有STL的使用都需要加）。

```c++
#include <vector>
#include <cstdio>

using namespace std;

int main() {

}
```

> 定义一个 vector 的方法如下：

```
vector<typename> name;
```



> 以上定义相当于定义了一个一维数组$name[size]$，只是$size$不确定，其长度可以根据需要而变化。其中$typename$可以是任何基本类型或容器，例如```int、double、char```等，当然里面也可以是结构体和其他STL容器。

##### 2. 3 $vector$的访问

> $vector$的访问很简单，使用时可以就把他视为一个数组。直接用下标进行访问。

> 假如一个$vector$类型变量$a$的长度是$len$，将其下表为$i$的位置赋值成$i$，可以通过如下方法实现。

```c++
    for (int i = 0; i < len; i ++)
        a[i] = i;
```


##### 2. 4 $vector$的常用函数

> 定义$a$是一个$vector$类型变量，在下文中理解成一个边长数组

```vector<int> a;```

* ```a.push_back(x)```
    令$a$的数组大小加一，并在最后一个位置放一个元素$x$，时间复杂度为$O(1)$。

* ```a.size()```
    函数返回当前$a$数组的大小，时间复杂度为$O(1)$。

* ```a.pop_back()```
    删除$a$中最后一个元素，并使数组大小减一，时间复杂度为$O(1)$。

* ```a.clear()```
    清空$a$中所有元素，令$a$数组大小为$o$，时间复杂度是$O(n)$，$n$为$a$数组中原来的元素个数。



##### 2. 5 $vector$的应用

> 一般当需要开$n$个数组，每个数组需要开的长度未知，但是总长度已知的情况下，可以开$n$个$vector$类型变量来进行存储，已达到节省空间的效果。

### 3. $stack$

##### 3. 1 $stack$的介绍

> stack翻译为**栈**，是STL中实现的一个**后进先出**的容器，与$vector$类似，也能看作一个变长的数组，但只能通过函数访问栈顶元素，不能对中间元素进行访问。

##### 3. 2 $stack$的定义

> 类似与$vector$，使用$stack$前，要先添加$stack$头文件，即```#include <stack>```。

> 定义一个$stack$的方法如下：

```stack<typename> name;```

>其中，$typename$可以是任何基本类型或者容器，$name$是栈的名字。

##### 3. 3 $stack$的常用函数

> 定义$a$是一个$stack$类型变量。

```stack<int> a;```

* ```a.push(x)```
    将$x$压入$a$的栈顶，时间复杂度为$O(1)$。
* ```a.top(x)```
    获取$a$中栈顶元素，时间复杂度为$O(1)$。
* ```a.pop(x)```
    弹出$a$中栈顶元素，时间复杂度为$O(1)$。
* ```a.empty()```
    用于检测$a$是否为空栈，空则返回$true$，否则返回$false$，时间复杂度为$O(1)$。
* ```a.size()```
    返回栈$a$中元素个数，时间复杂度为$O(1)$。

### 4. $queue$

##### 4. 1 $queue$的介绍

> $queue$翻译为**队列**，是STL中实现的一个**先进先出**的容器，与$vector$类似，可以看作是一个变长数组，但只能通过函数来访问队首或队尾元素，中间元素不能访问。

##### 4. 2 $queue$的定义

> 类似与$vector$，使用$queue$前，要先添加$queue$头文件，即```#include <queue>```。

> 定义一个$queue$的方法如下：

```queue<typename> name;```

>其中，$typename$可以是任何基本类型或者容器，$name$是栈的名字。

##### 4. 3 $queue$的常用函数

> 定义$a$是一个$queue$类型变量。

```queue<int> a;```

* ```a.push(x)```
    将$x$元素加入队列$a$队尾，时间复杂度为$O(1)$。
* ```a.front(),a.back()```  
    分别返回队首和队尾元素的值，时间复杂度为$O(1)$。
* ```a.pop()```
    让队首元素出队，时间复杂度为$O(1)$。
* ```a.empty()```
    用来检测队列$a$是否为空，若为空返回$true$，否则返回$false$，时间复杂度为$O(1)$

### 5. $priority$_$queue$

##### 5. 1 $prority$_$queue$的介绍

> $priority$_$queue$翻译为**优先队列**，一般用来解决一些贪心问题，其底层是用“堆”来实现的。

> 在优先队列中，任何时刻，队首元素默认是优先级最大的元素（大根堆）。可以不断往优先队列中添加某个优先级的元素，也可以不断弹出优先级最高的那个元素，每次操作其会自动调整结构，始终保证队首元素的优先级最高。

##### 5. 2 $priority$_$queue$的定义

> $priority$_$queue$是$queue$库中的容器，所以y而需要添加$queue$的头文件，即```#include <queue>```。

> 定义一个$priority$_$queue$的方法如下：

```priority_queue<typename> name;```
 
> 其中，$typename$可以是任何基本类型或者容器，$name$为优先队列的名字。

##### 5. 3 $priority$_$queue$的常用函数

> 和$queue$不一样的是，$priority$_$queue$没有$front()$和$back()$，而只能通过$top()$或$pop()$访问队首元素（也称堆顶元素），也就是优先级最高的元素。

> 定义$a$是一个$queue$类型变量。

```priority_queue<int> a;```

* ```a.push(x)```
    将$x$加入优先队列$a$，时间复杂度为$O(log_2^n)$，$n$为当前优先队列中的元素个数。加入后会自动调整$priority$_$queue$的内部结构，以保证队首元素(堆顶元素)的优先级最高。
* ```a.top()```
    返回优先队列$a$中给的队首元素，时间复杂度为$O(1)$。
* ```a.pop()```
    让优先队列$a$中队首元素(堆顶元素)出队，时间复杂度为$O(log_2^n)$，$n$为当前优先队列中的元素个数。出队后会自动调整$priority$_$queue$的内部结构，以保证队首元素(堆顶元素)的优先级最高。

---

## 三. 经典例题

1. 放球
> 有$n$个容器，$m$个球，告诉你每个球是在哪个容器，问每个容器里面有哪些球?

> 输入格式：
> 第一行两个整数$n,m$。
> 接下来$m$行，每行一个整数$a_i$表示第$i$个球属于哪个容器。
> $n,m \leq 10^5$

> 输出格式：
> 一共$m$行，对于第$i$行，第一个整数$num_i$表示第$i$个容器里球的数量，接下来$num_i$个数，从小到大依次输出在第$i$个容器中球的编号。

样例输入 | 样例输出
------------ | ------------
3 5 </br> 1 </br> 2 </br> 1 </br> 3 </br> 3 | 2 1 3 </br> 1 2 </br> 2 4 5

2. 栈

> 给定一个栈，$1$ ~ $n$依次进栈。有两种操作，一种是"IN"，表示将一个数进栈。另一个是"OUT"，表示将栈顶元素出栈，并输出它的值。读入$n$和操作顺序，并模拟这个过程。
> 对于任何"OUT"操作，保证栈中存在元素。"IN"和"OUT"分别有$n$个。

> 输入格式：
> 第一行一个正整数$n$，表示元素个数。
> 接下$2n$行，每行为"IN"或"OUT"中的一种操作。
> $n \leq 1000$

> 输出格式：
> 对于每个"OUT"操作，输出一行一个整数，表示栈顶元素。

样例输入 | 样例输出
------------ | ------------
4 </br> IN </br> IN </br> OUT </br> IN </br> OUT </br> OUT </br> IN </br> OUT | 2 </br> 3 </br> 1 </br> 4


3. 最大元素

> 现在有两种操作，一种是加入一个数$x$，另一种是去掉当前最大的数并输出它的值。现在有$n$次操作，要求对于所有第二种操作，输出删去数的值。
> 保证对于第二种操作，当前元素数量大于0。

> 输入格式：
> 第一行一个整数$n$表示操作数。
> 接下来$n$行，每行第一个正整数$type$等于$1$或$2$表示操作类型，若为$1$则为第一种操作，再读入一个数$x$表示要加入的数。若为$2$则为第二种操作。
> $n \leq 10^5$
> $a_i \leq 10^9$

> 输出格式：
> 对于所有$type=2$的输入，输出一个正整数表示当前的最大值。

样例输入 | 样例输出
------------ | ------------
5 </br> 1 3 </br> 1 2 </br> 2 </br> 1 4 </br> 1 4 </br> 2 </br> 2 | 3 </br>4 </br>4

---

## 四. 提高巩固

1. 括号匹配

> 给定一个只包含左右小括号的字符串$s$，若$s$中所有左右括号恰好能完全匹配，则输出$YES$，否则输出$NO$。

> 样例输入:
> 一行一个字符串$s$。
> $s$的长度小于$10^5$

> 样例输出：
> 若能恰好匹配则输出$YES$，否则输出$NO$。

样例输入 | 样例输出
------------ | ------------
()(()) | YES

2. 关系网络

> 有$n$个人，他们的编号为$1$ ~ $n$，其中有一些人相互认识，现在$x$想要认识$y$，可以通过他所认识的人来认识更多的人（如果$x$认识$y$、$y$认识$z$，那么$x$可以通过$y$来认识$z$），求出$x$最少需要通过多少人才能认识$y$。

> 输入格式：
> 第一行三个正整数$n,x,y$
> 接下来一个$n × n $的矩阵$a$，若$a[i][j]=1$则表示第$i$个人认识第$j$个人，$a[i][j]=0$则不认识。
> 保证$i=j$时$a[i][j]=0$。且对于任意$i,j$，$a[i][j] = a[j][i]$
> $x,y \leq n \leq 100$

> 输出格式：
> 输出一行一个数，表示$x$认识$y$最少需要通过的人数。


样例输入 | 样例输出
------------ | ------------
5 1 5 </br> 0 1 0 0 0  </br>  1 0 1 1 0  </br> 0 1 0 1 0  </br> 0 1 1 0 1  </br> 0 0 0 1 0 | 2

3. 序列合并

> 有两个长度都是$n$的序列$A$和$B$，在$A$和$B$中各取一个数相加可以得到$n^2$个和，求这$n^2$个和中最大的$n$个。

> 输入格式：
> 第一行一个正整数$n$。
> 第二行$n$个从大到小的正整数表示序列$A$。
> 第三行$n$个从大到小的正整数表示序列$B$。
> $n \leq 10^5$
> 序列$A,B$中的数不超过$10^9$

> 输出格式：
> 一行$n$个从大到小的正整数，表示和最大的$n$个数。


样例输入 | 样例输出
------------ | ------------
3 </br> 5 3 3 </br> 6 4 1| 11 9 9


