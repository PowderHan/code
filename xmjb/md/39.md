
# 小马加编信息学教案(三十九) 
# 图和$Floyd$

---

<!-- code_chunk_output -->

* [一. 课程内容](#一-课程内容)
* [二. 知识讲解](#二-知识讲解)
	* [1. 图的定义](#1-图的定义)
	* [2. 图的存储](#2-图的存储)
		* [2. 1 邻接矩阵](#2-1-邻接矩阵)
		* [2. 2 邻接表](#2-2-邻接表)
		* [2. 3 邻接矩阵和邻接表的比较。](#2-3-邻接矩阵和邻接表的比较)
	* [3. $Floyd$](#3-floyd)
		* [3. 1 $Floyd$的介绍](#3-1-floyd的介绍)
		* [3. 2 $Floyd$的原理](#3-2-floyd的原理)
* [三. 经典例题](#三-经典例题)
* [四. 提高巩固](#四-提高巩固)

<!-- /code_chunk_output -->

---

## 一. 课程内容
1. 图的定义
2. 图的存储
3. Floyd
---

## 二. 知识讲解

### 1. 图的定义

> 图由一些点和连接这些点的边组成，我们可以如下图给每个点一个编号

<img src="http://thyrsi.com/t6/670/1550041703x2890202402.png" width = "" height = "250" div align = center>

> 连接两个点$u,v$的边有两种。
* 一种是有向边，只能从一个点走到另一个点，如上图$1$号点和$4$号点之间的边，根据箭头方向，只能从$1$号点走到$4$号点。
* 另一种是无向边，可以在两个点之间任意走动，即可以从$u$走到$v$也可以从$v$走到$u$。

> 由有向边组成的图可叫做**有向图**，由无向边组成的图叫**无向图**。

> 另外我们可以给每条边一个权值，代表边的长度，那么可以定义两个点经过某条路径的距离为走过所有边的长度和。如下图中的红色路径。

<img src="http://thyrsi.com/t6/670/1550041722x2890202402.png" width = "" height = "250" div align = center>

> 仔细观察可以发现，从$2$号点到$3$号点有多条路径可以选择，但是下图标识的长度为$5$的路径是所有路径中最短的，那么可以将这条路叫做$2$节点到$3$节点的**最短路径**，长度为$5$。


<img src="http://thyrsi.com/t6/670/1550041738x2890202402.png" width = "" height = "250" div align = center>

### 2. 图的存储

> 考虑怎么在程序成存储一幅有$n$个点$m$条边的图，常用的方法有两种：邻接矩阵和邻接表。

##### 2. 1 邻接矩阵

> 我们可以用一个$n \times n$的二维数组$road$来存储这幅图的路径。对于由$u$指向$v$的有向边，将路径长度保存在$road[u][v]$处，若没有路径则令其等于$-1$。对于无向边，可以视为两条方向相反的有向边，将路径信息分别存储在$road[u][v]$和$road[v][u]$中。

##### 2. 2 邻接表

> 邻接矩阵可以很方便的知道任意两点间的连边情况，但是需要$n^2$的存储空间，当$n$比较大时就无法用邻接矩阵存储。

> 邻接矩阵的缺点是有很大一部分空间是没有存储边的信息的，会浪费掉。那么换个思路，只对出现在图中的边开空间存储。即对于每个点，不用一个大小为$n$的数组存储与每个点是否有边相连，而是只记录连出边的信息。

> 更具体的说，就是用$vector$将边的信息保存下来，我们可以用两个$vecotr$，一个记录这条边连向那个点，一个记录这条边的长度。比如有一条$u$到$v$长度为$len$的有向边：

```c++
	vector<int> poi[100], l[100];
	//用poi[i]记录i连出去的边连向哪个点
	//用l[i]记录i连出去的边的长度
	
	poi[u].push_back(v);
	l[u].push_back(len);
	//加入一条从u连向v的长度为len的有向边
	//若为无向边则再在v对应的poi和l中加入边即可
```

> 之前学过，$vector$是动态开空间的，那么只需要$O(m)$的空间就能把这副图中边的信息记录下来。

##### 2. 3 邻接矩阵和邻接表的比较。

| 功能 | 邻接矩阵 | 邻接表 |
| ------ | ------ | ------ |
| 所需空间 | $O(n^2)$ | $O(m)$ |
| 遍历所有边 | $O(n^2)$ | $O(m)$ |
| 访问两个点之间的边| $O(1)$| $O(m)$ |


* 对于所需空间上面已经提到

* 当要遍历一个点连出去的边时，对于邻接矩阵，需要将图中每个点访问一次，用$road$数组判断有没有连边。而邻接表直接访问$vector$即可。

* 当判断两个点之间有没有连边时，对于邻接矩阵，只需通过$road$数组判断。而邻接表要将整个$vector$遍历一次。

### 3. $Floyd$

##### 3. 1 $Floyd$的介绍

> $Floyd$是一种求一幅图中两两点之间最短路的算法，通过动态规划的思想实现。其采用邻接矩阵对边进行存储。 

##### 3. 2 $Floyd$的原理

> 记$f[i][j]$表示从点$i$到点$j$的最短路（若为无向图则$f[i][j]=f[j][i]$），那么我们可以先根据图中已有的边对其赋初始值。若两个点之间没有边相连，则为$\infty$。

```c++
	if (i == j) {
		f[i][j] = 0; 
		//自己到自己的距离是0
	} else {
		if (road[i][j] == -1) {
			f[i][j] = Inf; 
			//两点没有直接相连，距离为Inf，Inf为一个很大的常数。
		} else {
			f[i][j] = road[i][j];
			//两点有直接相连，对f数组赋初值
		}
	}
```

> 现在只考虑了两个点直接相连的情况，怎么将经过中间节点的路径也考虑上？由于图中两个点之间存在很多路径，经过中间点的可能性会很多，没办法一次性考虑完或者枚举。那么换个思路，可以每次只考虑一个中间点是否在其他点对的最短路径上。

> 我们用动态规划的思想，分$n$轮来更新$f$数组，对于第$k$轮，只考虑将编号为$1$到$k$作为中间点的路径，那么对于第$k+1$轮对于任意点对$i,j$只有两种情况：

* $i,j$之间的最短路径不经过中间点$k+1$，$f[i][j]=f[i][j]$
* $i,j$之间的最短路经过中间点$k+1$，$f[i][j]=f[i][k+1]+f[k+1][j]$，即从$i$先到$k+1$，再从$k+1$到$j$。

> 综上所述，对于第$k$轮，我们可以得到通过一下式子更新$f$数组

```c++
f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
```

> 经过$n$轮更新后的$f$数组就是考虑了所有点作为中间点的两两点间的最短路。

```c++
	for (int k = 1; k <= n; k ++) //枚举更新n轮
		for (int i = 1; i <= n; i ++)
			for (int j = 1; j <= n; j ++) //枚举点对
				f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
	//若f[i][j]等于Inf则i,j之间不连通，否则f[i][j]为i,j之间的最短路。
```

> 由于使用邻接表存储，所以复杂度为$O(n^2)$，由于要枚举$n$轮，每轮都要枚举$n^2$个点对，所以时间复杂度是$O(n^3)$。

---

## 三. 经典例题

1. 寻找联通块

> 给一幅$n$个点，$m$双向条边的图，问有多少个节点和$1$号节点在同一个联通块（若两个点能通过若干条路径到达则称两个点在同一个联通块）。

> 输入格式：
> 第一行两个整数$n,m$。
> 接下来$m$行，每行两个整数$u,v$表示一条$u$连向$v$的双向边。
> $n,m \leq 10^5$

> 输出格式：
> 一行一个整数表示有多少个节点和$1$号节点在同一个联通块。

样例输入 | 样例输出
------------ | ------------
6 5 </br> 1 2 </br> 2 4 </br> 3 5 </br> 5 6 </br> 3 6 | 3

2. 最短距离（1）

> 给一副$n$个点，$m$条双向边的图，问每个节点到$1$号节点至少经过多少条边，保证每个节点都能到达$1$号节点。

> 输入格式：
> 第一行两个整数$n,m$。
> 接下来$m$行，每行两个整数$u,v$表示一条$u$连向$v$的双向边。
> $n,m \leq 10^4$

> 输出格式：
> 一行$n$个整数，第$i$个整数表示第$i$个点到$1$号节点的最短距离。

$~$

样例输入 | 样例输出
------------ | ------------
4 5 </br> 1 2 </br> 2 4 </br> 4 3 </br> 2 3 </br> 1 4 | 0 1 2 1

3. 最短距离（2）

> 给定一副$n$个点$m$条边的无向图，现在有$t$组询问，每组询问给定$s_i$和$t_i$，询问这两个点之间的最短路径。保证没有重边。

> 输入格式：
> 第一行三个整数$n,m,t$。
> 接下来$m$行，每行三个整数$a_i,b_i,c_i$表示一条从$a_i$连向$b_i$长度为$c_i$的无向边。
> 然后$t$行，每行两个整数$s_i,t_i$，表示一组询问。
> $n \leq 100 $
> $m \leq 10000$

> 输出格式：
> 对于每组询问，输出一个整数表示最短距离。

样例输入 | 样例输出
------------ | ------------
5 6 3</br> 1 2 2 </br> 1 4 2 </br> 4 3 3 </br> 4 2 1 </br> 1 5 1 </br> 3 5 2 </br> 1 3 </br> 1 4 </br> 2 5| 3 </br> 2 </br> 3 


---
## 四. 提高巩固

1. 最好的地方

> 约翰拥有$p$个牧场.贝茜特别喜欢其中的$f$个.所有的牧场由$c$条双向路连接，第$i$路连接着$a_i,b_i$（双向），需要$t_i$单位时间来通过。作为一只总想优化自己生活方式的奶牛，贝茜喜欢自己某一天醒来，到达所有那$f$个她喜欢的 牧场的平均需时最小.那她前一天应该睡在哪个牧场呢？请帮助贝茜找到这个最佳牧场。

> 输入格式：
> 第一行三个整数$p,f,c$。
> 接下来$f$行，每行一个正整数表示贝茜喜欢的$f$个牧场。
> 接下来$c$行，每行三个正整数$a_i,b_i,t_i$表示一条路径。
> $n \leq 500$
> $c \leq 8000$
> $t \leq 900$

> 输出格式：
> 一个整数表示最佳牧场。

样例输入 | 样例输出
------------ | ------------
13 6 15 </br>11</br> 13</br>10</br>12</br>8</br>1</br>2 4 3</br>7 11 3</br>10 11 1</br>4 13 3</br>9 10 3</br>2 3 2</br>3 5 4</br>5 9 2</br>6 7 6</br>5 6 1</br>1 2 4</br>4 5 3</br>11 12 3</br>6 10 1</br>7 8 7</br>|10


2. 牛栏

>  Farmer John想让他的奶牛准备郡级跳跃比赛，贝茜和她的伙伴们正在练习跨栏。她们很累，所以她们想消耗最少的能量来跨栏。 显然，对于一头奶牛跳过几个矮栏是很容易的，但是高栏却很难。于是，奶牛们总是关心路径上最高的栏的高度。 奶牛的训练场中有$n$个站台，分别标记为$1..n$。所有站台之间有$m$条单向路径，第$i$条路经是从站台$s_i$开始，到站台$e_i$，其中最高的栏的高度为$h_i$。无论如何跑，奶牛们都要跨栏。 奶牛们有$ti$个训练任务要完成。第$i$个任务包含两个数字$a_i$和$b_i$，表示奶牛必须从站台$a_i$跑到站台$b_i$，可以路过别的站台。奶牛们想找一条路径从站台$a_i$到站台$b_i$，使路径上最高的栏的高度最小。你的任务就是写一个程序，计算出路径上最高的栏的高度的最小值。

> 输入格式：
> 第一行三个整数，$n,m,ti$
> 接下来$m$行，每行三个整数$s_i,e_i,h_i$表示一条单向路径，
> 接下来$t$行，每行两个整数$a_i,b_i$表示一个训练任务。
> $a_i,b_i,s_i,t_i \leq n \leq 300$
> $m \leq 25000$
> $t \leq 40000$
> $h_i \leq 10^6$

> 输出格式：
> 对于每个训练任务，输出一个整数表示路径上最高护栏的最小值。

$~$
$~$
$~$

样例输入 | 样例输出
------------ | ------------
5 6 3</br>1 2 12</br>3 2 8</br>1 3 5</br>2 5 3</br>3 4 4</br>2 4 8</br>3 4</br>1 2</br>5 1 | 4</br>8</br>-1

3. 奶牛大赛

> Farmer John的$n$头奶牛们最近参加了场程序设计竞赛。在赛场上，奶牛们按$1..n$依次编号。每头奶牛的编程能力不尽相同，并且没有哪两头奶牛的水平不相上下，也就是说，奶牛们的编程能力有明确的排名。 整个比赛被分成了若干轮，每一轮是两头指定编号的奶牛的对决。如果编号为$a$的奶牛的编程能力强于编号为$b$的奶牛($a \not= b$) ，那么她们的对决中，编号为$a$的奶牛总是能胜出。 Famer John想知道奶牛们编程能力的具体排名，于是他找来了奶牛们所有$m$轮比赛的结果，希望你能根据这些信息，推断出尽可能多的奶牛的编程能力排名。比赛结果保证不会自相矛盾。

> 输入格式：
> 第一行两个整数$n,m$
> 接下来$m$行，每行两个整数$a,b$表示一场决斗，且第一头奶牛获胜。
> $n \leq 100$
> $m \leq 4500$

> 输出格式：
> 一行一个整数表示可以确定排名的奶牛的个数。


样例输入 | 样例输出
------------ | ------------
5 5 </br>4 3</br>4 2</br>3 2</br>1 2</br>2 5| 2