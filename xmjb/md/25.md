
# 小马加编信息学教案(二十五) 
# 二分查找
---

* [一. 课程内容](#一-课程内容)
* [二. 知识讲解](#二-知识讲解)
	* [1. 定义与基本思路](#1-定义与基本思路)
		* [1. 1 定义](#1-1-定义)
		* [1. 2 基本思路](#1-2-基本思路)
	* [2. 时间复杂度分析](#2-时间复杂度分析)
	* [3. 优点和缺点](#3-优点和缺点)
* [三. 经典例题](#三-经典例题)
* [四. 提高巩固](#四-提高巩固)

---

## 一. 课程内容
1. 定义与基本思路
2. 时间复杂度分析
3. 优点和缺点

---

## 二. 知识讲解

### 1. 定义与基本思路

##### 1. 1 定义

> 二分查找也叫折半查找，主要用来解决查找一个有序序列中某个元素的位置的问题，不同于直接按顺序查找，其通过特殊的查找方式来提高效率。

##### 1. 2 基本思路

> 现在有问题：问一个标号为$1$ ~ $n$的有序序列$a[1..n]$，哪个位置的数等于 $k$，若没有则输出 $-1$。

> 数据如下
>  $n = 6$
>  $a$[] = {$1, 3, 5, 6, 7, 8$}
>  $k = 7$

>1. 顺序查找：直接从 $1$开始往后一个个找，当找到第一个大于 $k$ 的位置时结束，若找到$k$就输出位置。这种做法要访问整个数组，时间复杂度是 $O(n)$。

<img src="http://thyrsi.com/t6/670/1550039464x2890202977.png" width = "" height = "110" div align = center>

>2.  二分查找：我们不直接一个个找到 $k$的位置，我们设置一个区间 $ [l, r]$，表示我们要找的数在区间 $[l, r]$中，一开始 $l = 1, r = n$。

<img src="http://thyrsi.com/t6/670/1550039480x2890202977.png" width = "" height = "130" div align = center>

> 接着令区间中点$mid = \frac{l+r}{2}$，则$a[mid]$与$k$有3种关系：
>   1. 若$a[mid] = k$则证明查找到了$k$所在的位置，结束程序
>   2. 若$a[mid] > k$由于数组有序，那么$k$肯定在$mid$左边，令$r = mid - 1$
>   3. 若$a[mid] < k$由于数组有序，那么$k$肯定在$mid$右边，令$l = mid + 1$


<img src="http://thyrsi.com/t6/670/1550039549x2890202977.png" width = "" height = "120" div align = center>

> $a[mid] < k$即为第三种情况，令$l = mid + 1$

<img src="http://thyrsi.com/t6/670/1550039491x2890202977.png" width = "" height = "130" div align = center>

> 然后再求出$[l, r]$的中点$mid$，与$k$比较。不断重复这个过程，缩小$k$所在的区间的长度，若中途找到$k$则，算法结束，否则，当$l > r$ 说明不存在$k$所在的区间，即$k$不在$a$中。

> 核心代码 
```c++
	int l = 1, r = n, ans;
	while (l <= r) {
		int mid = (l + r) / 2;
		if (a[mid] == k) {
			ans = mid;
			break;
		} 
		// 第一种情况
		if (a[mid] > k) r = mid - 1;
		// 第二种情况
		if (a[mid] < k) l = mid + 1;
		// 第三种情况
	}
```

> 根据上面的过程，不难发现二分查找就是每次将我们可能查找的区间分为两块，然后通过比较$a[mid]$和$k$的大小关系判断$k$在哪一边，由于是分成两块，因此称之为二分查找。

### 2. 时间复杂度分析

> 我们知道顺序查找的复杂度是$O(n)$的，那么二分查找的复杂度是多少呢？

> 一开始我们规定$k$所在的区间是$[1, n]$，即整个$a$数组，每一轮操作将当前区间分成两半，通过与$a[mid]$比较，确定$k$是在哪一半，然后将缩小查找区间为原来的一半。
> 由于每次查找都会减少一半长度的区间，那么进行$log_2^{n}$次操作后，区间长度就会变成$0$，算法结束。

> 那么我们得出结论，二分查找算法最多进行$log_2^{n}$次，所以时间复杂度是$O(log_2^{n})$的，远远低于顺序查找的$O(n)$。

### 3. 优点和缺点

> 优点：查找的时间复杂度为是$O(log_2^{n})$远好于$O(n)$。

> 缺点：查找数组中的元素要有序，而排序本身就至少要$O(nlog_2^n)$的复杂度。

---

## 三. 经典例题

1. 查找元素（1）

> 给定有序序列```1,2,4,6,7,10,11,15,19,21,23,27```，要求用二分查找寻找$21$在序列中排第几个。求出一共要查找多少轮，并写下每一轮的$l,r,mid$。

2. 查找元素（2）

> 输入$n,k$，和一个有$n$个元素的从小到大的有序整数序列$a$，$a$中元素各不相同，若$k$在有序序列中出现，则输出其位置，否则输出$-1$。

> 输入格式：
> 第一行两个整数$n,k$分别表示元素个数和待查找的数。
> 第二行$n$个数，表示有序序列$a$。
> $n\leq 10^5$
> $k,a_i\leq10^9$

> 输出格式：
> 一个整数，表示$k$的位置或$-1$。

$~$

样例输入 | 样例输出
------------ | ------------
7 10 </br> 1 2 4 6 7 10 11 | 6

3. 寻找排名

> 输入$n,k$，和一个有$n$个元素的无序整数序列$a$，保证$a$中元素互不相同。问$k$是$a$中第几大的元素，保证$k$在$a$中出现。
> 用排序加二分实现。

> 输入格式：
> 第一行两个整数$n,k$分别表示元素个数和待查找的数。
> 第二行$n$个数，表示序列$a$。
> $n\leq 10^5$
> $k,a_i\leq10^9$


> 输出格式：
> 一个整数表示$k$在$a$中的排名。


样例输入 | 样例输出
------------ | ------------
7 10 </br> 5 3 10 7 2 11 19 | 3

---

## 四. 提高巩固

1. 查找元素（3）

> 输入$n,k$，和一个有$n$个元素的从小到大的有序整数序列$a$，$a$中元素互不相同。$k$为完全平方数，问是否存在位置$i$满足$a_i^2=k$，若存在则输出位置$i$否则输出$-1$。

> 输入格式：
> 第一行两个整数$n,k$分别表示元素个数和完全平方数。
> 第二行$n$个数，表示有序序列$a$。
> $n\leq 10^5$
> $k,a_i\leq10^9$

> 输出格式：
> 一个整数，表示位置或$-1$。

样例输入 | 样例输出
------------ | ------------
7 49 </br> 1 2 4 6 7 10 11 | 5

2. 范围查找

> 输入$n,k$，和一个有$n$个元素的从小到大的有序整数序列$a$（可能出现重复元素）。问$k$在数组$a$中出现的最左端的位置和最右端的位置，分别用二分查找实现，保证$k$在$a$数组中出现。

> 输入格式：
> 第一行两个整数$n,k$分别表示元素个数和待查找的数。
> 第二行$n$个数，表示有序序列$a$。
> $n\leq 10^5$
> $k,a_i\leq10^9$

> 输出格式：
> 一行两个整数$l,r$，分别表示$k$出现的最左端和最右端的位置。

样例输入 | 样例输出
------------ | ------------
7 7 </br> 1 2 7 7 7 10 11 | 3 5

3. 查找峰值

> 给定一个含$n$整数的序列$a$，$a$中元素互不相同，满足存在一个峰值点$i$，其左边的元素单调递增，右边的元素单调递减，$a_i$为序列的最大值，要求用二分查找找到峰值点是多少？

> 输入格式：
> 第一行一个整数$n$表示元素的个数。
> 第二行$n$个整数，表示序列$a$。
> $n \leq 10^5$
> $a_i \leq 10^9$

> 输出格式:
> 一个整数表示峰值点的位置。

样例输入 | 样例输出
------------ | ------------
7 </br> 1 2 4 6 5 3 | 4

> 样例解释：
> $6$所在的位置$4$为峰值点。