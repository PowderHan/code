
# 小马加编信息学教案(四十) 
# 并查集

---

<!-- code_chunk_output -->

* [一. 课程内容](#一-课程内容)
* [二. 知识讲解](#二-知识讲解)
	* [1. 并查集的介绍](#1-并查集的介绍)
	* [2. 并查集的基本思路](#2-并查集的基本思路)
		* [2. 1 思路一](#2-1-思路一)
		* [2. 2 思路二](#2-2-思路二)
		* [2. 3 思路三](#2-3-思路三)
* [三. 经典例题](#三-经典例题)
* [四. 提高巩固](#四-提高巩固)

<!-- /code_chunk_output -->

---

## 一. 课程内容
1. 并查集的介绍
2. 并查集的基本思路
---

## 二. 知识讲解

### 1. 并查集的介绍

> 并查集从名字可以看出，主要涉及两种基本操作，对集合的**合并**和**查找**。

> 加入现在有$n$个元素，一开始可以视为每个元素都为独立的一个集合。有两种操作：
* 合并：给定$x,y$，将$x,y$所处的集合合并。
* 查询：给定$x,y$，判断他们是否在同一个结合。

### 2. 并查集的基本思路

##### 2. 1 思路一

> 一种简单的思路就是对于每个集合可以规定一个关键点，并令$key[i]$表示第$i$个元素所处集合的关键点，一开始每个元素都为独立的一个集合，所以```key[i] = i```。

<img src="http://thyrsi.com/t6/670/1550043019x2890202707.png" width = "" height = "230" div align = center>

> 考虑如何处理合并和查找操作。

* 查找：这个很好理解，直接判断关键点是否相同即可。对于元素$x,y$，若```key[x] == key[y]```，则$x,y$在同一个集合，否则不在。

* 合并：那么相当于将$x$所处集合所有元素的关键点变为$key[y]$，即将$x$所处集合中所有元素加到$y$集合。

> 由于存在合并操作，需要遍历所有$key$值等于$key[x]$的元素，所以时间复杂度是$O(n^2)$的。

##### 2. 2 思路二

> 思路一中，每次进行合并操作都需要遍历整个数组，考虑怎么优化。

> 考虑将思路一中的元素$3$和元素$5$所处的集合合并，我们尝试只修改元素$1$的$key$值。令```key[1] = 7```

<img src="http://thyrsi.com/t6/670/1550043897x2890202498.png" width = "" height = "230" div align = center>

> 那么查找时就不能直接比较$key$值是否相同，但是换个方式思考，其实$key$值的指向就是合并集合的过程，一个集合中所有的元素一直沿着箭直跳，肯定会跳到同一个元素，即为当前集合的关键点，那么我们判断$x,y$是否在同一个集合时，只需判断他们的关键点是否相同即可。

```c++
//获取集合的关键点
int get(int x) {
	if (key[x] == x) return x;
	return get(key[x]);
}
```
```c++
	scanf("%d%d", &x, &y);
	if (get(x) == get(y)) printf("YES\n"); else printf("NO\n");
	// 若x,y属于一个集合则输出"YES"，否则输出"NO"。
```

> 合并$x,y$属于的两个集合时，只需要把$x$集合的关键点指向$y$集合的关键点即可。即


```c++
	key[get(x)] = get(y);
```


> 但是每次执行$get$函数都可能向上跳$n$次。所以总的复杂度还是$O(n^2)$。

##### 2. 3 思路三

> 那么继续对思路二进行优化，思路二主要寻找关键点时要不断往$key$值方向跳。其实每次我们访问了$get(x)$后就可以将$key[x]$修改成$get(x)$，减少很多不必要的操作，大大优化时间复杂度。

```c++
int get(int x) {
	if (key[x] == x) return x;
	key[x] = get(key[x]);
	return key[x];
}
```

> 同样，将思路一中元素$3$和元素$5$按升级后的方法进行合并后，就会变成下图。

<img src="http://thyrsi.com/t6/670/1550043915x2890202498.png" width = "" height = "230" div align = center>

> 对于合并操作仍然采用上面思路二的方法。

```c++
	if (get(x) != get(y)) key[get(x)] = get(y);
	//如果get(x) == get(y)则说明x和y已经在一个集合了。
```

> 用这种方法，时间复杂度就可以优化到$O(n\alpha(n))$，$\alpha(n)$可以视为常数，所以可以近似为时间复杂度是$O(n)$。

> 思路三就是我们常说的并查集算法，能较快的对集合进行合并和判断两个元素是否再同一个集合。

---

## 三. 经典例题

1. 并查集	

> 加入现在有$n$个元素，一开始可以视为每个元素都为独立的一个集合。有两种操作：
> * 合并：给定$x,y$，将$x,y$所处的集合合并。
> * 查询：给定$x,y$，判断他们是否在同一个结合。
> 现在总共有$m$个操作。

> 输入格式：
> 第一行两个整数$n,m$。 
> 接下来$m$个操作，每个操作包括三个整数$z_i,x_i,y_1$。若$z_i=1$则将$x_i,y_i$所在集合合并。若$z_i=2$则输出$x_i$与$y_i$是否在同一集合内，若是输出$Y$，否则输出$N$。
> $n \leq 10^4$
> $m \leq 2*10^5$

> 输出格式：
> 对于每个查询操作输出$Y$或$N$。

$~$
$~$
$~$

样例输入 | 样例输出
------------ | ------------
4 7 </br>2 1 2</br>1 1 2</br>2 1 2</br>1 3 4</br>2 1 4</br>1 2 3</br>2 1 4|N</br>Y</br>N</br>Y

2. 村村通

> 某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？

> 输入格式：
> 每个输入文件包含若干组测试测试数据。
> 每组测试数据的第一行给出两个用空格隔开的正整数$n,m$，分别是城镇数目和道路数目；随后的$m$行对应$m$条道路，每行给出一对用空格隔开的正整数$u,v$，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从$1$到$n$编号。
> 当$n=0$时输入结束。
> 注意：两个城市间可以有多条道路。
> $n \leq 1000$

> 输出格式：
> 对于每组数据输出一个整数表示还需要建设的道路条数。

样例输入 | 样例输出
------------ | ------------
4 2 </br>1 3</br>4 3</br>3 3</br>1 2</br>1 3</br>2 3</br>5 2</br>1 2</br>3 5</br>999 0</br>0|1</br>0</br>2</br>998

3. 修复公路

> A地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。给出A地区的村庄数$n$，和公路数$m$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）

> 输入格式：
> 第一行两个整数$n,m$
> 接下来$m$行，每行三个整数$x,y,t$，表示一条连接村庄$x,y$的道路在时间$t$修好。
> $x,y \leq n \leq 1000$
> $m,t \leq 10^5$

> 输出格式：
> 如果全部公路修复完毕仍然存在两个村庄无法通车，则输出$-1$，否则输出最早什么时候任意两个村庄能够通车。

样例输入 | 样例输出
------------ | ------------
1 2 6 </br> 1 3 4</br> 1 4 5</br> 4 2 3| 5

---

## 四. 提高巩固

1. pSort

> 给定一个含有$n$个元素的数列，第i号元素开始时数值为$i$,位置$i$的元素可以与距离为$d[i]$的元素进行交换。再给定一个$1..n$的全排列，问初始的数列可否交换成给定的样式。

> 输入格式：
> 第一行一个整数$n$。
> 第二行$n$个互不相同的整数表示目标数列。
> 第三行$n$个整数表示$d[i]$。
> $n \leq 100$

> 输出格式：
> 若能交换到给定的样式则输出$YES$，否则输出$NO$。

样例输入 | 样例输出
------------ | ------------
7</br>4 2 5 1 3 7 6</br>4 6 6 1 6 6 1 | YES


2. 搭配购买

> 明天就是母亲节了，电脑组的小朋友们在忙碌的课业之余挖空心思想着该送什么礼物来表达自己的心意呢？听说在某个网站上有卖云朵的，小朋友们决定一同前往去看看这种神奇的商品，这个店里有n朵云，云朵已经被老板编号为$1..n$，并且每朵云都有一个价值，但是商店的老板是个很奇怪的人，他会告诉你一些云朵要搭配起来买才卖，也就是说买一朵云则与这朵云有搭配的云都要买，电脑组的你觉得这礼物实在是太新奇了，但是你的钱是有限的，所以你肯定是想用现有的钱买到尽量多价值的云。

> 输入格式：
> 第一行三个整数$n,m,w$表示有$n$朵云，$m$种搭配，并现在有$w$元。
> 接下来$n$行，每行两个整数$c_i,d_i$表示第$i$朵云的价钱和价值。
> 接下来$m$行，每行两个整数$u_i,v_i$表示$u_i,v_i$必须一起购买。
> $n,w \leq 10^4$
> $m \leq 5000$

> 输出格式：
> 一行一个整数表示可以获得的最大价值。

样例输入 | 样例输出
------------ | ------------
5 3 10</br>3 10</br>3 10</br>3 10</br>5 100</br>10 1</br>1 3</br>3 2</br>4 2</br>| 1

3. 信息传递

> 有$n$个同学（编号为$1$到$n$）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为$i$的同学的信息传递对象是编号为$t_i$
​的同学。
> 游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？

> 输入格式：
> 第一行包含一个整数$n$，表示有$n$个人。
> 第二行$n$个整数，第$i$个整数为$t_i$。
> $n \leq 2*10^5$

> 输出格式：
> 一行一个整数，表示游戏可以进行多少轮。

样例输入 | 样例输出
------------ | ------------
5</br>2 4 2 3 1| 3